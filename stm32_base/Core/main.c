/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/


#include <global_defines.h>
#include <delay_ms.h>

#include <uart_1.h>
#include <uart_1_parsing.h>

#include <uart_2.h>
#include <uart_2_parsing.h>

#include <uart_3.h>
#include <lcd.h>
#include <rtos.h>
#include <mirf.h>

#include "protocol.h"
#include "parking_space.h"
#include "cmd_interp.h"

#include "flash.h"


void RCC_DeInit(void);			//	сбрасывает настройки тактирования
void SetSysClockTo72(void);		//	настраивает новое тактирование
void GPIO_Init (void);			//	настраивает входы выходы


void write_INIT_RTOS_in_lcd(void);
void send_byte_to_uart(void);

void system_reset(void);

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{

	RCC_DeInit();		//	сбрасываем тактирование
	SetSysClockTo72();	//	тактирование от внешнего 8 MHz -> 72 MHz
	GPIO_Init();		//	настройка портов
	SysTick_Init();		//	запуск системного таймера (для функции delay_ms())
	LCD_init();
	uart1_init (9600);
	uart2_init (4800);
//	uart3_init (9600);

	RTOS_Init();						//	запускает RTOS
//	RTOS_SetTask(write_INIT_RTOS_in_lcd, 3000, 0);		// для теста (через ~10 секунд включится светодиод на отладочной плате)
//	RTOS_DeleteTask(write_INIT_RTOS_in_lcd);

//	NRF_Init();



//======================================================================

	FLASH_Init();
	FLASH_Unlock();
	FLASH_Erase_Page(LAST_PAGE);

	uint32_t byte_4 = flash_read(LAST_PAGE);

	for (uint8_t i = 0; i < 4; i++)		{put_byte_UART1(byte_4 >> (8 * i));}

	uint8_t size = 10;
	uint8_t data[size];	for (uint8_t i = 0; i < size; i++)	{data[i] = 0x44+i;}

	Internal_Flash_Write(&data[0], LAST_PAGE, size);
//	FLASH_Lock();

	delay_ms(500);
	byte_4 = flash_read(LAST_PAGE);

	for (uint8_t i = 0; i < 4; i++)		{put_byte_UART1(byte_4 >> (8 * i));}
//======================================================================


/*
//	Для светодиода на плате
	//============== Настройка вывода TX (PA9) ==================================================================================
		uint8_t offset = ( 9 - 8 ) * 4;				//	(9-8) * 4 = 4
		GPIOA->CRH &= ~( GPIO_BITS_MASK << offset );	//
		GPIOA->CRH |= ( OUTPUT_PUSH_PULL << offset );		//	альтернативная функция с выходом пуш-пул	AF_PUSH_PULL
	//===========================================================================================================================
*/

	//============== Настройка вывода TX (PB10) =================================================================================
		uint8_t offset =  (USART3_TX_pin - 8) * 4;				//	(10-8) * 4 = 8
		GPIOB->CRH &= ~( GPIO_BITS_MASK << offset );	//
		GPIOB->CRH |= ( OUTPUT_PUSH_PULL << offset );		//	альтернативная функция с выходом пуш-пул	AF_PUSH_PULL
	//===========================================================================================================================

//	RTOS_SetTask(send_byte_to_uart, 1000, 0);

	Parking_Space_Init();	//	инициализируем функции системы Parking_Space

	put_byte_UART1(adr_in_uart_1);
	put_byte_UART2(adr_in_uart_2);

	FLASH->KEYR = 0x45670123;	//	первый ключ для разблокировки FLASH памяти
	FLASH->KEYR = 0xCDEF89AB;	//	второй ключ для разблокировки FLASH памяти
/*
	FLASH_Latency_0 - 0 < SYSCLK≤ 24 MHz
	FLASH_Latency_1 - 24 MHz < SYSCLK ≤ 48 MHz
	FLASH_Latency_2 - 48 MHz < SYSCLK ≤ 72 MHz
*/


	while(1)
	{
		RTOS_DispatchTask();	// обязательно крутится тут (иначе поставленные задачи будут вызываться из прерывания RTOS_timer
		trigger();	//	функция управляющая системой Parking_Space
		switch (Parking_Space_CONTROL)
		{
			case DO_PARSING_CMD:	{find_pack_from_uart_1();}	break;	//	искать пакет от ПК
			case DO_CMD_EXE:		{pack_from_uart_1_exe();}	break;	//	выполнить пакет от ПК
			case DO_PARSING_ACK:	{find_pack_from_uart_2();}	break;	//	искать пакет от подчиненного
			case DO_ACK_EXE:		{pack_from_uart_2_exe();}	break;	//	выполнить пакет от подчиненого

			case DO_PARKING_SPACE:	{Parking_Space();}			break;
		}
	}
}


// для теста RTOS
void write_INIT_RTOS_in_lcd(void)
{
	LCD_Command(0x01);		//	очистка дисплея					(LCD_CLEAR)
	delay_ms(2);			//	долгая операция

	LCD_Command(LCD_SETDDRAMADDR | 0);	//	писать с нулевого адреса
	LCDsendString("INIT RTOS");
}





void RCC_DeInit(void)
{
	SET_BIT(RCC->CR, RCC_CR_HSION);							//	Включим для начала HSI (внутренний генератор 8 МГц)
	while(READ_BIT(RCC->CR, RCC_CR_HSIRDY == RESET)) {}		//	Дождёмся его стабилизации

	MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, 0x80U);				//	Сбросим калибровку

	CLEAR_REG(RCC->CFGR);									//	Полностью очистим конфигурационный регистр
	while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET) {}	//	Дождёмся очистку бита SWS

	CLEAR_BIT(RCC->CR, RCC_CR_PLLON);						//	Отключим PLL
	while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET) {}	//	Ждем отключения

	CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON);		//	Выключим HSE и его детектор тактового сигнала
	while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET) {}	//	Ждем отключения

	CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);						//	Сбросим бит, разрешающий использование внешнего генератора

	SET_BIT(RCC->CSR, RCC_CSR_RMVF);						//	Сбросим флаги всех прерываний от RCC

	CLEAR_REG(RCC->CIR);									//	Также запретим все прерывания от RCC
}



void SetSysClockTo72(void)
{
  SET_BIT	(RCC->CR, RCC_CR_HSEON);						//	Включим наш HSE, дождавшись его стабилизации (HSI - вунтренняя RC цепочка))
  while(READ_BIT(RCC->CR, RCC_CR_HSERDY == RESET)) {}		//	Дождёмся его стабилизации

  CLEAR_BIT	(FLASH->ACR, FLASH_ACR_PRFTBE);					//	Disable the Prefetch Buffer
  SET_BIT	(FLASH->ACR, FLASH_ACR_PRFTBE);					//	Enable the Prefetch Buffer (так надо)

  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, FLASH_ACR_LATENCY_2);	//	выбираем максимальную задержку

  // AHB prescaler											//	0xxx: SYSCLK not divided
  CLEAR_BIT	(RCC->CFGR, RCC_CFGR_HPRE_0);
  CLEAR_BIT	(RCC->CFGR, RCC_CFGR_HPRE_1);
  CLEAR_BIT	(RCC->CFGR, RCC_CFGR_HPRE_2);
  CLEAR_BIT	(RCC->CFGR, RCC_CFGR_HPRE_3);

  // APB low-speed prescaler (APB1)							//	100: HCLK divided by 2
  CLEAR_BIT	(RCC->CFGR,   RCC_CFGR_PPRE1_0);
  CLEAR_BIT	(RCC->CFGR,   RCC_CFGR_PPRE1_1);
  SET_BIT	(RCC->CFGR,   RCC_CFGR_PPRE1_2);

  // APB high-speed prescaler (APB2)						//	0xx: HCLK not divided
  CLEAR_BIT	(RCC->CFGR,  RCC_CFGR_PPRE2_0);
  CLEAR_BIT	(RCC->CFGR,  RCC_CFGR_PPRE2_1);
  CLEAR_BIT	(RCC->CFGR,  RCC_CFGR_PPRE2_2);

  // PLL entry clock source
  SET_BIT	(RCC->CFGR,  RCC_CFGR_PLLSRC);					//	1: HSE oscillator clock selected as PLL input clock

  // HSE divider for PLL entry
  CLEAR_BIT	(RCC->CFGR,  RCC_CFGR_PLLXTPRE);				//	0: HSE clock not divided

  // PLL multiplication factor								//	0111: PLL input clock x 9
  SET_BIT	(RCC->CFGR,  RCC_CFGR_PLLMULL_0);
  SET_BIT	(RCC->CFGR,  RCC_CFGR_PLLMULL_1);
  SET_BIT	(RCC->CFGR,  RCC_CFGR_PLLMULL_2);
  CLEAR_BIT	(RCC->CFGR,  RCC_CFGR_PLLMULL_3);

  SET_BIT(RCC->CR, RCC_CR_PLLON);									//	Разрешим работу PLL
  while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != (RCC_CR_PLLRDY)) {}		//	Дождёмся его включения

  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL);				//	Выберем PLL в качестве источника системного тактирования
  while(READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL) {}	//	ждем применения данного действия

}



void GPIO_Init (void)
{
	uint32_t tmpreg;	//	пока используется для задержки.
	(void) tmpreg;
	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);				//	Alternate function IO clock enable	(запуск тактирования для SWD отладчика
	tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);	//	Delay after an RCC peripheral clock enabling

	CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);
	SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_JTAGDISABLE);		//	NOJTAG: JTAG-DP Disabled and SW-DP Enabled	(для отладчика)

	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN);				//	enable port A	(запуск тактирование порта A)
	tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN);	//	Delay after an RCC peripheral clock enabling


	//======= LED PC13 =========================================================================
		RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
		uint8_t offset;
		uint8_t LED_pin = 13;
		offset = (LED_pin - 8) * 4;						//	0 * 4 = 16
		GPIOC->CRH &= ~( GPIO_BITS_MASK << offset );	//	стереть 4 бита
		GPIOC->CRH |= ( OUTPUT_PUSH_PULL << offset );	//	записать 4 бита
		GPIOC->BSRR = ( 1 << LED_pin );				//	установка линии в 1
		//GPIOC->BRR = ( 1 << LED_pin );				//	установка линии в 0
	//==========================================================================================

}
void send_byte_to_uart(void)
{
//	put_byte_UART1(0xD1);
	put_byte_UART1(Parking_Space_CONTROL);
	put_byte_UART1(Parking_Space_STATUS);
//	put_byte_UART1(0xD1);

//	put_byte_UART2(0xD2);
//		put_byte_UART3(0xD3);

	RTOS_SetTask(send_byte_to_uart, 1000, 0);

}


// На всякий случай, если понадобится, то перезагрузка делается вот так:
void system_reset(void)
{
   SCB->AIRCR = (0x5FA << SCB_AIRCR_VECTKEYSTAT_Pos) | SCB_AIRCR_SYSRESETREQ_Msk;
   __DSB();
  while(1);
}

