/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/


#include <global_defines.h>
#include <delay_ms.h>
#include <uart_1.h>
#include <uart_2.h>
#include <uart_3.h>
#include <lcd.h>
#include <rtos.h>
#include <mirf.h>

void RCC_DeInit(void);			//	сбрасывает настройки тактирования
void SetSysClockTo72(void);		//	настраивает новое тактирование
void GPIO_Init (void);			//	настраивает входы выходы


void write_INIT_RTOS_in_lcd(void);


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{

	RCC_DeInit();		//	сбрасываем тактирование
	SetSysClockTo72();	//	тактирование от внешнего 8 MHz -> 72 MHz
	GPIO_Init();		//	настройка портов
	SysTick_Init();		//	запуск системного таймера (для функции delay_ms())
	LCD_init();
	uart1_init (9600);
	uart2_init (9600);
	uart3_init (9600);

	RTOS_Init();						//	запускает RTOS
	RTOS_SetTask(write_INIT_RTOS_in_lcd, 3000, 0);		// для теста (через ~10 секунд включится светодиод на отладочной плате)
	RTOS_DeleteTask(write_INIT_RTOS_in_lcd);




/*
//	Для светодиода на плате
	//============== Настройка вывода TX (PA9) ==================================================================================
		uint8_t offset = ( 9 - 8 ) * 4;				//	(9-8) * 4 = 4
		GPIOA->CRH &= ~( GPIO_BITS_MASK << offset );	//
		GPIOA->CRH |= ( OUTPUT_PUSH_PULL << offset );		//	альтернативная функция с выходом пуш-пул	AF_PUSH_PULL
	//===========================================================================================================================
*/

	uint8_t message[5] = {0x71, 0x02, 0x03, 0x04, 0x05};		//	тестовое сообщение

	NRF_Init();





		uint8_t Stage = 0;



	while(1)
	{
		/*
		put_byte_UART1(0xD1);
		put_byte_UART2(0xD2);
		put_byte_UART3(0xD3);
		delay_ms(500);
		GPIOC->BSRR = ( 1 << 13 );				//	установка линии в 1
		delay_ms(500);
		GPIOC->BRR = ( 1 << 13 );				//	установка линии в 0
		*/

		delay_ms(1000);



//		RTOS_DispatchTask();	// обязательно крутиться тут (иначе поставленные задачи будут вызываться из прерывания RTOS_timer
	}
}


// для теста RTOS
void write_INIT_RTOS_in_lcd(void)
{
	LCD_Command(0x01);		//	очистка дисплея					(LCD_CLEAR)
	delay_ms(2);			//	долгая операция

	LCD_Command(LCD_SETDDRAMADDR | 0);	//	писать с нулевого адреса
	LCDsendString("INIT RTOS");
}





void RCC_DeInit(void)
{
	SET_BIT(RCC->CR, RCC_CR_HSION);							//	Включим для начала HSI (внутренний генератор 8 МГц)
	while(READ_BIT(RCC->CR, RCC_CR_HSIRDY == RESET)) {}		//	Дождёмся его стабилизации

	MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, 0x80U);				//	Сбросим калибровку

	CLEAR_REG(RCC->CFGR);									//	Полностью очистим конфигурационный регистр
	while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET) {}	//	Дождёмся очистку бита SWS

	CLEAR_BIT(RCC->CR, RCC_CR_PLLON);						//	Отключим PLL
	while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET) {}	//	Ждем отключения

	CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON);		//	Выключим HSE и его детектор тактового сигнала
	while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET) {}	//	Ждем отключения

	CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);						//	Сбросим бит, разрешающий использование внешнего генератора

	SET_BIT(RCC->CSR, RCC_CSR_RMVF);						//	Сбросим флаги всех прерываний от RCC

	CLEAR_REG(RCC->CIR);									//	Также запретим все прерывания от RCC
}



void SetSysClockTo72(void)
{
  SET_BIT	(RCC->CR, RCC_CR_HSEON);						//	Включим наш HSE, дождавшись его стабилизации (HSI - вунтренняя RC цепочка))
  while(READ_BIT(RCC->CR, RCC_CR_HSERDY == RESET)) {}		//	Дождёмся его стабилизации

  CLEAR_BIT	(FLASH->ACR, FLASH_ACR_PRFTBE);					//	Disable the Prefetch Buffer
  SET_BIT	(FLASH->ACR, FLASH_ACR_PRFTBE);					//	Enable the Prefetch Buffer (так надо)

  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, FLASH_ACR_LATENCY_2);	//	выбираем максимальную задержку

  // AHB prescaler											//	0xxx: SYSCLK not divided
  CLEAR_BIT	(RCC->CFGR, RCC_CFGR_HPRE_0);
  CLEAR_BIT	(RCC->CFGR, RCC_CFGR_HPRE_1);
  CLEAR_BIT	(RCC->CFGR, RCC_CFGR_HPRE_2);
  CLEAR_BIT	(RCC->CFGR, RCC_CFGR_HPRE_3);

  // APB low-speed prescaler (APB1)							//	100: HCLK divided by 2
  CLEAR_BIT	(RCC->CFGR,   RCC_CFGR_PPRE1_0);
  CLEAR_BIT	(RCC->CFGR,   RCC_CFGR_PPRE1_1);
  SET_BIT	(RCC->CFGR,   RCC_CFGR_PPRE1_2);

  // APB high-speed prescaler (APB2)						//	0xx: HCLK not divided
  CLEAR_BIT	(RCC->CFGR,  RCC_CFGR_PPRE2_0);
  CLEAR_BIT	(RCC->CFGR,  RCC_CFGR_PPRE2_1);
  CLEAR_BIT	(RCC->CFGR,  RCC_CFGR_PPRE2_2);

  // PLL entry clock source
  SET_BIT	(RCC->CFGR,  RCC_CFGR_PLLSRC);					//	1: HSE oscillator clock selected as PLL input clock

  // HSE divider for PLL entry
  CLEAR_BIT	(RCC->CFGR,  RCC_CFGR_PLLXTPRE);				//	0: HSE clock not divided

  // PLL multiplication factor								//	0111: PLL input clock x 9
  SET_BIT	(RCC->CFGR,  RCC_CFGR_PLLMULL_0);
  SET_BIT	(RCC->CFGR,  RCC_CFGR_PLLMULL_1);
  SET_BIT	(RCC->CFGR,  RCC_CFGR_PLLMULL_2);
  CLEAR_BIT	(RCC->CFGR,  RCC_CFGR_PLLMULL_3);

  SET_BIT(RCC->CR, RCC_CR_PLLON);									//	Разрешим работу PLL
  while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != (RCC_CR_PLLRDY)) {}		//	Дождёмся его включения

  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL);				//	Выберем PLL в качестве источника системного тактирования
  while(READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL) {}	//	ждем применения данного действия

}



void GPIO_Init (void)
{
	uint32_t tmpreg;	//	пока используется для задержки.
	(void) tmpreg;
	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);				//	Alternate function IO clock enable	(запуск тактирования для SWD отладчика
	tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);	//	Delay after an RCC peripheral clock enabling

	CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);
	SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_JTAGDISABLE);		//	NOJTAG: JTAG-DP Disabled and SW-DP Enabled	(для отладчика)

	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN);				//	enable port A	(запуск тактирование порта A)
	tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN);	//	Delay after an RCC peripheral clock enabling


	//======= LED PC13 =========================================================================
		RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
		uint8_t offset;
		uint8_t LED_pin = 13;
		offset = (LED_pin - 8) * 4;						//	0 * 4 = 16
		GPIOC->CRH &= ~( GPIO_BITS_MASK << offset );	//	стереть 4 бита
		GPIOC->CRH |= ( OUTPUT_PUSH_PULL << offset );	//	записать 4 бита
		GPIOC->BSRR = ( 1 << LED_pin );				//	установка линии в 1
		//GPIOC->BRR = ( 1 << LED_pin );				//	установка линии в 0
	//==========================================================================================

}
